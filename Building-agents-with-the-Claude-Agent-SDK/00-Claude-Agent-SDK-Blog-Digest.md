# Claude Agent SDK 博客精读笔记

> 原文：Building agents with the Claude Agent SDK（2025-09-29）

## 核心要点速览
- Claude Code SDK 正式升级为 Claude Agent SDK，定位从“代码伙伴”扩展到“给 Claude 配备一台计算机的通用代理框架”。
- 核心设计哲学：让模型拥有程序员日常使用的同一套操作系统级工具（文件系统、bash、编辑器、运行时），以可重复的 agent loop（Gather → Act → Verify）驱动复杂任务。
- SDK 默认支持 subagents、上下文压缩（compact）、丰富的工具体系（自定义工具、bash、MCP、代码生成），帮助开发者组合出面向金融、助理、客服、科研等不同垂直的代理。
- 可靠性来自“先收敛后求广”的策略：先通过 agentic search 与文件系统组织上下文，再按需引入语义检索；验证阶段强调规则化反馈、可视化校对与 LLM 评审的分层使用。
- 持续改进关键在于观察失败样例、补齐工具/反馈/上下文结构，必要时构建代表性评测集。

## SDK 愿景与定位
- **背景**：Claude Code 在内部已超越写代码用途，被用于调研、视频、笔记与几乎所有“agent loops”，促成 SDK 更名。
- **核心价值**：给 Claude 一台“电脑”，让它像人类知识工作者一样通过终端驱动任务，而非只在上下文中“想象”结果。
- **目标用户**：需要快速搭建垂直代理（金融、助理、客服、研究等）的开发团队；SDK 提供工具拼积木，开发者聚焦业务编排与规则。

## 典型代理场景
- **金融分析**：综合投资组合、外部 API、脚本计算。
- **个人助理**：跨应用管理日程、旅行、简报，跟踪上下文。
- **客服**：在高不确定度请求中搜集数据、调用外部接口、分级处理。
- **深度研究**：跨大规模文档检索、交叉引用、写出结构化报告。

## Agent Loop 解析
Claude Agent SDK 的默认工作流沿用 Claude Code 的闭环：Gather Context → Take Action → Verify Work。

### Gather Context
- **Agentic search + 文件系统**：用目录结构作为“可拉取的潜在上下文”，通过 `ls`、`grep`、`tail` 等脚本自助选择片段；结构设计即是“上下文工程”。
- **语义检索**：速度快但维护复杂、透明度低，官方建议先用 agentic search，必要时再组向量索引以覆盖更多变体或性能要求。
- **Subagents**：SDK 原生支持；用途一是并行拆解任务，二是隔离上下文，主代理仅接收摘要结果，适合大规模搜索和筛选。
- **Compact（压缩）**：长时间运行的代理会自动对历史对话做摘要，避免上下文溢出，延续 Claude Code `/compact` 命令能力。

### Take Action
- **Tools 即主要动作**：工具在上下文中高度显性，应只暴露“最想让代理执行的动作”，减少噪音；官方提供自定义工具接口。
- **Bash & 脚本**：通用兜底手段，允许代理自由组合命令、读写文件、运行代码，如解析附件、转换格式、检索数据等。
- **代码生成**：Claude 擅长把复杂流程固化为脚本或程序（如自动建表、生成 PPT/Excel、邮件规则），提供精确、可复用的行动单元。
- **MCP（Model Context Protocol）**：标准化外部服务接入，自动处理鉴权；通过 MCP 服务器即可无缝调用 Slack、GitHub、Drive、Asana 等工具。

### Verify Work
- **规则校验**：最可靠的反馈形式，示例包括 TypeScript + Lint、邮箱地址合法性检查、历史往来警示等。
- **可视化反馈**：对于 UI/文档/HTML 等视觉输出，可借助截图（如 Playwright MCP 服务器）回传图像并让模型审查布局、层次与样式。
- **LLM 评审**：次优方案，用于对语气、风格等模糊标准做辅助判断；适合愿意以延迟换取性能的场景，可通过独立子代理承担。

## 执行能力组件一览
- **文件系统即上下文**：通过目录约定、缓存“Conversations”等资料库，让代理在执行中自助调取关键信息。
- **工具生态**：将高频动作（`fetchInbox`、`searchEmails` 等）封装为正式工具，既节省上下文又提供更可控的输入/输出模式。
- **Subagent Orchestration**：针对多线程搜索或评审任务，创建专用子代理，主代理负责合并结果与决策。
- **上下文维护**：用 compact、日志裁剪、分阶段持久化等策略，确保长链任务不会信息爆炸。

## 测试与持续改进策略
- 观察失败样例，检查是否“缺信息”“缺规则”“缺工具”或“缺 evals”。
- 调整搜索/检索 API 结构，让关键信息更容易被发现。
- 为易错点添加更具约束力的规则或校验脚本，用失败即报错的方式倒逼自我纠错。
- 构建代表性测试集，对新增功能做回归评估，维持可度量的性能基线。

## 对 SanBot 设计的启发
- **与三层架构对齐**：
  - 基础设施层可直接映射 Claude Agent SDK 的“给模型一台电脑”理念，优先完善 exec、文件操作、工具注册等硬能力。
  - 认知层可借鉴 agentic search → 语义检索的渐进策略，以及 subagent + compact 机制管理 L0/L1/L2 记忆。
  - 自主层的自我进化与工具生成可复用“代码即行动”的思想，通过脚本化创造新工具并沉淀到 `~/.sanbot/tools/`。
- **工具设计规范化**：按照 SDK 推荐，将 SanBot 的工具列表控制在“真正高频、可组合”的范围，降低模型分心；并给出强约束的输入参数与错误输出。
- **闭环与评测**：在 MVP 成功标准（exec、工具生成、复用）基础上，引入规则校验/visual diff/LLM judge 三层反馈，确保 SanBot 的 agent loop 在引入自工具后仍可控。
- **演进路线**：先完成“给模型电脑”的基础能力与 agentic search，后续再考虑语义检索、MCP 接入及批量子代理编排。

## 建议的后续实践
1. 结合 SanBot 场景梳理最小工具集与 bash 安全沙箱策略。
2. 在 docs/ 中进一步沉淀 agentic search 目录规范与 compact 策略，形成可执行的“上下文工程”指南。
3. 设计一套覆盖 exec/工具生成/自检的 eval cases，为下一阶段 MVP 验收建立量化标准。
