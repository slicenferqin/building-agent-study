# 05. Subagents 与 Context Management：长任务时代的规模化关键

## 1) 为什么需要 Subagents（子代理）
单代理在长任务中会遇到两个硬问题：
- 上下文拥堵（context congestion）
- 任务串行导致吞吐低（low throughput）

`Subagents` 提供了两个关键解法：
- `Parallelization（并行化）`：多个任务同时推进。
- `Context Isolation（上下文隔离）`：每个子代理在独立上下文工作，只把结果摘要回传。

## 2) 子代理的正确定位
子代理不是“把主代理拆碎”，而是“把高噪音/高体量/高独立性任务外包”。

典型适配任务：
- 大规模代码/日志检索
- 多来源资料并行研究
- 重型测试与报告归纳

不适配任务：
- 需要连续对话细调的创作类任务
- 强依赖主上下文细粒度历史的任务

## 3) Context Compaction（上下文压缩）怎么理解
压缩并不神秘，本质是“保主线、弃噪音”：
- 清理过时工具输出
- 抽取关键决策与结论
- 保持后续推理可继续

合理预期：
- 压缩会有信息损失，所以持久规则不要只放会话里。
- 把长期有效规则放入持久文件（如项目记忆/配置文档）。

## 4) Context Editing 与 Memory Tool 的新增意义
在 2025 的上下文管理发布中，两个能力值得重点关注：

### Context Editing（上下文编辑）
- 在接近上下文上限时自动清理陈旧工具结果。
- 目标是延长有效运行时间，降低 token 浪费。

### Memory Tool（记忆工具）
- 通过文件式持久存储，把重要知识放到上下文窗口外。
- 允许跨会话复用“经验与状态”，适合长期代理。

这两者一起构成：
`短期工作记忆（context window） + 长期外部记忆（memory files）`

## 5) 长任务架构建议（Long-Running Agent Pattern）

### Pattern A: Main Agent + Search Subagents
- 主代理负责任务编排和决策。
- 子代理负责并行检索与筛选。
- 主代理统一汇总并决策下一步。

### Pattern B: Worker Subagents + Verifier Subagent
- Worker 生成候选结果。
- Verifier 独立检验并反馈。
- 主代理决定是否继续迭代。

### Pattern C: Session Context + Persistent Memory
- 当前回合信息放 context。
- 跨回合策略与结论放 memory。

## 6) 成本与延迟视角
子代理会带来额外开销（模型调用、初始化上下文），但可换取：
- 更低主上下文污染
- 更高并行吞吐
- 更稳定的长任务表现

所以不是“越多子代理越好”，而是“把最合适的任务交给子代理”。

## 7) 常见误区
- 把所有任务都扔给子代理，导致协调成本上升。
- 子代理返回原始海量输出，而非摘要要点。
- 没有子代理权限边界，放大安全风险。
- 只依赖自动压缩，不做外部记忆沉淀。

## 8) 你应该带走的结论
- Subagents 的价值是“隔离噪音 + 并行吞吐”，不是炫技式多代理。
- 长任务可靠运行，必须结合 compaction/context editing/memory 三件套。
- 真正可扩展的 agent，一定有“短期上下文 + 长期记忆”的分工架构。

## Checklist
- 是否明确定义了哪些任务应外包给子代理？
- 子代理是否只回传结构化摘要而非原始长输出？
- 是否有上下文压缩与持久记忆协同策略？
- 是否对每个子代理设置了最小权限原则？
