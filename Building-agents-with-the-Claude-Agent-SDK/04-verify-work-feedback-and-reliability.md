# 04. Verify Work：没有验证，就没有可靠 agent

## 1) 为什么 Verify 是决定性环节
`Verify Work（结果验证）` 的目标不是“做完后看一眼”，而是把 agent 从“会行动”升级为“可交付”。

在 agent loop 里，验证决定两件事：
- 这轮是否算完成。
- 下一轮该如何修正。

## 2) 三类验证机制（按可靠性排序）

### A. Rule-based Validation（规则验证）
例如 lint、类型检查、单元测试、格式约束、业务规则断言。

优点：
- 稳定、可重复、可审计。
- 失败信号明确，便于自动修复。

这是最推荐的验证主干。

### B. Visual Feedback（视觉反馈）
适用于 UI、HTML 邮件、报表、文档排版等可视任务。

验证维度通常包括：
- Layout（布局）
- Styling（样式）
- Hierarchy（信息层级）
- Responsiveness（响应式表现）

本质是把“看起来对不对”变成可被模型消费的反馈输入。

### C. LLM-as-a-judge（模型评审）
让另一个模型做“模糊标准”的评估（如语气、风格、礼貌度）。

优缺点：
- 优点：覆盖难以形式化的主观指标。
- 缺点：稳定性与一致性不如硬规则，且有额外时延和成本。

建议定位：辅助评审，不要作为唯一验证。

## 3) 验证不是末尾动作，而是循环驱动器
常见错误是“全部完成后一次性验证”。

更稳健的做法是 `incremental verification（增量验证）`：
- 小步改动 -> 小步验证
- 失败即回环修复

这样能显著降低错误累积与回滚成本。

## 4) 设计有效验证器（Verifier）的方法

### 1. 可判定（Decidable）
验证条件必须清晰到“能 pass/fail”。

### 2. 可定位（Localizable）
失败信息应指出具体位置和原因，便于 agent 定向修复。

### 3. 可行动（Actionable）
错误输出要能直接转化为下一步动作建议。

### 4. 可组合（Composable）
多个验证器可拼接成门禁链：
`schema -> lint -> test -> integration check`

## 5) Evaluator-Optimizer 思想
`Evaluator-Optimizer（评估-优化）` 是验证驱动迭代的经典模式：
- Optimizer 生成候选结果。
- Evaluator 给出反馈。
- Optimizer 依据反馈继续优化。

这个模式很适合“初稿可接受但可继续提升”的任务，如文案、研究报告、复杂查询策略。

## 6) 可靠性设计中的“分层门禁”
推荐把验证分成三层：
- L1: 快速硬规则（语法、类型、必填字段）
- L2: 业务规则（权限、状态流转、数据一致性）
- L3: 软评估（用户体验、语气风格、可读性）

这样可以先便宜地筛掉大部分错误，再做昂贵评估。

## 7) 常见误区
- 只做 LLM judge，不做规则校验。
- 验证器只给“失败”，不给“为何失败”。
- 一次大改后统一验证，导致修复成本爆炸。
- 没有失败预算与停止条件，反复优化没有边界。

## 8) 你应该带走的结论
- 验证是 agent 可靠性的“主引擎”，不是锦上添花。
- 最可靠组合是“规则优先 + 视觉补充 + LLM评审兜底”。
- 让验证输出可行动，是提升 agent 自修复能力的关键。

## Checklist
- 是否优先构建了规则化验证器？
- 验证失败信息是否能直接指导修复？
- 是否采用增量验证而不是末尾一次性验证？
- 对软性指标是否有一致性保障方案（多评审/阈值/抽检）？
